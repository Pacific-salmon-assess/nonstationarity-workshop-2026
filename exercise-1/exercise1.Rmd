---
title: 'Exercise 1: Assessing nonstationarity in spawner-recruit dynamics'
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Overview

The following exercises are intended to give participants a broad understanding of the statistical nuances of estimating nonstationarity in spawner-recruit time-series, with practical applications using the [samEst package](https://github.com/Pacific-salmon-assess/samEst). You may choose to 'knit' this document ('[exercise1.Rmd](https://github.com/Pacific-salmon-assess/nonstationarity-workshop-2026/blob/main/exercise-1/exercise1.Rmd)') to an HTML file, for visualization - or simply read through the text here. We encourage you to modify the R code chunks to experiment with each section to explore the mechanics of the simulations and model testing.

# Forms of non-stationarity, and their alternatives

Non-stationarity in the context of spawner-recruit dynamics refers to system parameters (i.e. max. recruitment, $log(\alpha)$, density-dependence, $\beta$ or $S_{max}$, or even recruitment variability, $\sigma$) that change through time rather than act as static or stable parameters that govern system dynamics.

To start let's consider the standard Ricker logistic model of population dynamics:

$$R_t = S_t \cdot e^{\alpha - \beta \cdot S_t + \epsilon_t}$$
$$\epsilon_t \sim N(0, \sigma)$$

Where $R_t$ is the abundance of adult recruits for brood cohort at year $t$, $S_t$ is the parent spawning abundance in brood cohort year $t$, $\alpha$ is the intrinsic productivity representing maximum adult recruits produced per spawning parent (at theoretical $S_t$ = 0, since it is an intercept), $\beta$ is the per-capita reduction in recruitment per spawning parent - and $S_{max}$ is the inverse of this quantity (representing the spawning abundance where total recruitment is maximized), $\epsilon_t$ is a normal deviate (but log-normal on the real scale of recruitment) representing deviance (or noise; represented by the scale or standard deviation parameter, $\sigma$) in the recruitment process for that brood cohort year from the system parameters expectation.

This equation can be linearized with some rearrangement of the terms, which is how we will fit this in practice - as it then becomes a standard linear regression, in terms of $log(R_t/S_t)$:

$$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$$

Note that we have substituted $S_{max}$ for $\beta$ from the previous equation, because 1) $S_{max}$ is a biologically meaningful parameter and 2) this is the formulation used in `samEst`.

Let's begin to explore this model with some real-world examples. Below you will find sections with numerous example datasets.

## Stable (or static, or equilibrium) dynamics

Let's begin by visualizing the sort of spawner-recruit time-series one may obtain from this model - when parameters are stable through time. We will do this through simulated data - we have made a function to simulate a generic Pacific salmon life cycle, in this case where fish return at ages 3, 4, or 5. We mimic the real world by creating annual run sizes from the total recruits spawned by each brood cohort, allow for harvest on the run (in this case, the harvest is just random irrespective of run size - but later we will allow for more realistic harvest control rules), and the 'escapement' of the run becomes the spawners for that year's brood cohort (and the cycle continues...).

The simulation is governed by our familiar Ricker parameters ($log(\alpha)$, $S_{max}$, $\sigma$), as well as an option to change the time-series length ($N$). Feel free to alter these parameters and see the resulting changes to the simulated datasets. To get a sense of some real-world distributions of the key parameters you can view some empirical distributions from a meta-analysis of spawner-recruit dynamics [here](https://pacific-salmon-assess.github.io/nonstationary_dynamics/#2_Stock_parameters_-_static).

```{r, simulation functions,echo=FALSE}
source('../exercise-1/sim_functions.R')
```

```{r, static ricker simulation,fig.width=6,fig.height=8}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from... ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50 #time series length

#For this workshop, we've made a function to simulate spawner-recruit dynamics, if you are very keen you can dig into it in the exercise-1/sim_functions.R file.
df.st=salmon_sim(log.a=log.a,smax=smax,sigma=sigma,N=N,form='static')

#visualize your simulated time-series
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #plot data
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2) #Spawner Recruit curve

#linearized
plot(df.st$logRS~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),xlab='spawners',ylab='log(R/S)') #plot data
pred2=log.a-S_p/smax
lines(pred2~S_p,lwd=2) #Spawner Recruit curve
```

Try changing the key Ricker parameters and note how the spawner-recruit curve shifts in kind.

We will use various `samEst` functions to estimate this model (and others) from the simulated spawner-recruit time-series.

There are two forms for model fitting that we included in this package - one using *Template Model Builder* (*TMB*), which uses Laplace approximation of the marginal likelihood to estimate parameter values (i.e. maximum likelihood estimates, MLE), the other form is a Bayesian method using *Stan*. We won't get into great detail about all the nuances of the theory and practice of these two model forms, but the main point for their implementation in `samEst` is that the former will give fast point estimates and has an option for no priors on the parameters, while the latter will give full posterior distributions of parameter estimates - so it's easier to work with the full uncertainty of the parameters and also requires priors on each parameter.

For the stationary form of the Ricker model, the two functions are: `ricker_TMB()` and `ricker_stan()`. You can call up either function (e.g. `??ricker_TMB`) to see the available arguments. For the rest of this exercise, we will use the *TMB* versions for speed and ease, you are welcome to switch these to *Stan* implementations, see the final section of advanced options for those interested.

Fit the *TMB* estimate of the Ricker curve with `samEst`. See [here](https://github.com/Pacific-salmon-assess/samEst?tab=readme-ov-file#install-instructions) for instructions to install `samEst`.  

```{r, static ricker estimation TMB,fig.width=6,fig.height=4}
library(samEst)
#ricker_TMB requires data-frame or list with S = a vector of spawning abundances, and logRS = a vector of log(recruits/spawner)

st.fit1=ricker_TMB(data=df.st,silent=T)#note silent = T just suppresses the updates on the likelihood gradient, the default includes priors - you can set priors_flag = 0 will turn off priors on Ricker parameters

#st.fit1=ricker_stan(data=df.st,ac=F) #alternative Stan variant
```

How do the estimates compare to the true values in the simulation?

real (i.e. declared above) vs. estimated $log(\alpha)$:

```{r, static estimates loga}
#We can view the MLE estimates of the key parameters by calling them up from the function
c(log.a,st.fit1$logalpha)
```
real vs. estimated $S_{max}$:

```{r, static estimates smax}
c(smax,
st.fit1$Smax)

```

real vs. estimated $\sigma$:

```{r, static estimates sigma}
c(sigma,
st.fit1$sigma)
```

Let's visualize the prediction (red) compared to true (black):

```{r, static ricker estimation plot,fig.width=6,fig.height=4}
#compare the estimated curve to the true curve:
plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #plot data
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2) #spawner-recruit curve (from simulation)
pred.est=exp(st.fit1$logalpha-S_p/st.fit1$Smax)*S_p
lines(pred.est~S_p,col='darkred',lwd=2) #spawner-recruit curve (predicted)

```

You may find the estimated (red) vs. true (black) Ricker curves are slightly off - but largely in the same realm. The more important aspect is whether the key biological reference points - e.g. spawners that maximize sustainable yield ($S_{msy}$) or the harvest rate at maximum sustainable yield ($U_{msy}$) - are close enough, as these are the management quantities that we're hoping to derive from these curves. These can be calculated directly from the Ricker parameters as:

$$S_{msy} = (1 - LambertW(e^{1-log(\alpha)}))/\beta$$

$$U_{msy} = 1 - LambertW(e^{1-log(\alpha)})$$

In `samEst`, these can be implemented via `smsyCalc()` and `umsyCalc()`, which we will apply to our true known parameters - but these are also standard outputs that are generated from the estimated functions (e.g. `ricker_TMB()`).

$S_{msy}$:

```{r, static est Smsy}
true.smsy=smsyCalc(log.a,b=1/smax)
c(true.smsy, st.fit1$Smsy) #true and estimated smsy

```

$U_{msy}$:

```{r, static est umsy}
true.umsy=umsyCalc(log.a)
c(true.umsy,st.fit1$Umsy)

```

### Priors  

Note that the default of `ricker_TMB()` applies priors on the parameters, as we generally encourage this to restrict the parameter space to areas that are biologically relevant. The default $S_{max}$ prior is fairly informative, which we set as a normal distribution, with the mean as half the maximum observed spawner abundance and a standard deviation of double of that same quantity. This is to prevent estimates of capacity that are widely beyond what's ever been observed (e.g. >10x the highest observed spawner estimate) and is based on an empirical ratio without any priors applied.

In some cases, you may have strong priors derived from external information - e.g. watershed area, or some other estimate. You can set custom priors directly in this function (and others). Here we can see how that works and changes the previous estimate - prior function plotted in blue:

```{r, stable with priors}
st.fit2=ricker_TMB(data=df.st,silent=T,Smax_mean=10000,Smax_sd=500) #setting prior to be higher for Smax, with low variance

plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #plot data
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2) #spawner-recruit curve (simulated relationship)
pred.est1=exp(st.fit1$logalpha-S_p/st.fit1$Smax)*S_p
lines(pred.est1~S_p,col='darkred',lwd=2) #spawner-recruit curve (predicted relationship)
pred.est2=exp(st.fit2$logalpha-S_p/st.fit2$Smax)*S_p
lines(pred.est2~S_p,col='navy',lwd=2) #spawner-recruit curve (new Smax prior)
```


## Stable, but autocorrelated, recruitment dynamics

The previous example is the sort of idealized scenario one would hope for a real population - stable dynamics over a long period - with normally distributed fluctuations in year-to-year production (i.e. log(R/S)). In reality, many fish populations, including Pacific salmon, have autocorrelated variation in recruitment dynamics - that is production tends to be self-similar from year-to-year resulting in strings of good or bad years for recruitment. This likely arises from environmental conditions that tend to be self-similar (e.g. temperature, bottom-up productivity, etc.). We can revise the static model to include this autocorrelation in recruitment variance:

$$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$$

$$\epsilon_t = \rho \cdot \epsilon_{t-1}  + \sqrt{1-\rho^{2\Delta t}}\cdot \delta_t$$

$$\delta_t \sim N(0, \sigma)$$

The key difference here is that the annual recruitment deviance $\epsilon_t$ now includes both a random annual fluctuation ($\delta_t$) and a 1-year lagged autocorrelation term ($\rho \cdot \epsilon_{t-1}$) where the level of autocorrelation ($\rho$, ranging from -1 to 1) dictates the 'memory' in system dynamics. Positive values of $\rho$ indicate that successive years of recruitment are more similar to each other, while negative values indicate that successive years are more dissimilar - which could emerge from strong inter-cohort competitive effects. In real spawner-recruit time-series, autocorrelation is almost always positive (see empirical estimates by species [here](https://pacific-salmon-assess.github.io/nonstationary_dynamics/#25_Rho_(autocorrelation))), so we will focus on this in our simulation (but feel free to change it to negative if you're curious).

We will add this to our simulated stable dynamics to see how it changes the spawner-recruit curve and parameter estimates.

```{r, autocorrelated stable dynamics}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
rho = 0.9 #autocorrelation parameter - the scale of 'memory' in recruitment deviations

df.ac=salmon_sim(log.a=log.a,smax=smax,sigma=sigma,N=N,rho=rho,form='autocorr')

```

Let's visualize this SR curve and the residuals through time. To highlight the time-series element of recruitment dynamics we'll colour code observations by year of the simulation.

```{r, autocorrelated SR plot,fig.width=7,fig.height=9}
par(mfrow=c(2,1))
plot(df.ac$R~df.ac$S,bty='l',type='n',xlim=c(0,max(df.ac$S)),ylim=c(0,max(df.ac$R)),xlab='spawners',ylab='recruits') 
lines(df.ac$R~df.ac$S,lwd=0.5,col=adjustcolor('darkgray',alpha.f=0.5))
points(df.ac$R~df.ac$S,pch=21,bg=viridis::viridis(length(df.ac$S))) #plot data
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners

#expectation based on true Ricker parameters:
S_p=seq(0,max(df.ac$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2) #spawner-recruit curve

#residual plot
plot(df.ac$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(df.ac$eps,pch=21,bg=viridis::viridis(length(df.ac$S)))

```

Lets's compare this to the same system with no autocorrelation (note if you changed the Ricker parameters in the previous section these will not be directly comparable, if not - re-run the previous section with equivalent Ricker parameters). Note 'eps' = $\epsilon_t$ = the residuals from the true parameters.

```{r, stable dynamics comp plot, fig.width=7,fig.height=9}
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',type='n',pch=21,xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #plot data
lines(df.st$R~df.st$S,lwd=0.5,col=adjustcolor('darkgray',alpha.f=0.5))
points(df.st$R~df.st$S,pch=21,bg=viridis::viridis(length(df.st$S)))
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2) #spawner-recruit curve

#residual plot
plot(df.st$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(df.st$eps,pch=21,bg=viridis::viridis(length(df.st$S)))
```

What do you notice about the temporal patterns in the residuals?

Let's see how this effects parameter estimates. To account for autocorrelation in our estimation models, we set the `ac` option in `ricker_TMB()` or `ricker_stan()` to `TRUE`.

First let's see how it performs on the autocorrelated dataset.

```{r, ac est}
ac.fit.ac=ricker_TMB(data=df.ac,ac=TRUE,silent=T)

#ac.fit.ac=ricker_stan(data=df.st,ac=T) #alternative stan variant

#true vs. estimated autocorrelation
c(rho,ac.fit.ac$rho)
#true vs estimated smax
c(smax,ac.fit.ac$Smax)
#true vs estimated log(alpha)
c(log.a,ac.fit.ac$logalpha)
#true vs estimated Smsy
c(smsyCalc(log.a,1/smax),ac.fit.ac$Smsy)
#true vs estimated Umsy
c(umsyCalc(log.a),ac.fit.ac$Umsy)
```

Let's visualize the model fit, we can use the `samEst` function `static_sr_plot()`:

```{r, ac estimates 1,fig.width=7,fig.height=9}
static_sr_plot(data=df.ac,mod=ac.fit.ac,plot.params=TRUE) #note - plot.params will print out the main Ricker parameters 
```

What if we don't account for autocorrelation, what parameters will we get?

```{r, ac estimates 3,fig.width=7,fig.height=9}
ac.fit.st=ricker_TMB(data=df.ac,ac=FALSE,silent=T)

#true vs. estimated autocorrelation
c(rho,ac.fit.st$rho)
#true vs estimated smax
c(smax,ac.fit.st$Smax)
#true vs estimated log(alpha)
c(log.a,ac.fit.st$logalpha)
#true vs estimated Smsy
c(smsyCalc(log.a,1/smax),ac.fit.st$Smsy)
#true vs estimated Umsy
c(umsyCalc(log.a),ac.fit.st$Umsy)

static_sr_plot(data=df.ac,mod=ac.fit.st,plot.params=TRUE) 
```

What differences do you find in the Ricker parameter estimates and residual plots for when you account for (or not) autocorrelation in the model?

Will it detect any autocorrelation in the entirely stable dataset?

```{r, ac estimates 2}
st.fit.ac=ricker_TMB(data=df.st,ac=TRUE,silent=T)

st.fit.ac$rho
```

### Model selection  

There are a few ways to gauge whether autocorrelation in recruitment may exist, in part you can (after some practice) visualize it in the residuals, you can test the parameter with the two model forms as well. One way we could potentially discriminate between the two model forms is using model selection criteria, ***which the *samEst* *TMB* model functions provide*** estimates of both the $AIC_c$ and $BIC$, which are estimated as:

$$AIC_c = -2log(L) + 2k(k+1)/(n-k-1)$$

$$BIC = klog(n) - 2log(L)$$

where $L$ is the model likelihood (estimated from the normal probability density function in our case), $k$ is the number of parameters (so in our comparison the autocorrelation model has +1 parameters), and $n$ is the number of observations. The lower $AIC$ or $BIC$ value, the more support there is for that model.

```{r, ac model selection}
#autocorrelated data fit with autocorrelation vs. fit with static model
c(ac.fit.ac$AICc,
ac.fit.st$AICc
)

#autocorrelated fit with autocorrelation vs. fit with static model
c(st.fit.ac$BIC,st.fit1$BIC)
```

We can further transform these estimates from each model into model 'weights', which give an estimate of the relative difference in likelihood support among models $I$ as:

$$w_i = e^{-AIC_i/2}/\sum(e^{-AIC_{i:I}/2})$$

We have a `samEst` function, `model_weights()` that will perform this calculation.

```{r, ac model weights}
#autocorrelated fit with autocorrelation vs. fit with static model - AIC model weights
model_weights(c(ac.fit.ac$AICc,ac.fit.st$AICc),form='TMB')

#autocorrelated fit with autocorrelation vs. fit with static model - BIC model weights
model_weights(c(ac.fit.ac$BIC,ac.fit.st$BIC),form='TMB')
```

What can you conclude from this? Is there more support for a static or autocorrelated model in this autocorrelated simulation?
 
What about when we apply these models in the fully stable system?

```{r, st model selection}
#stable fit with autocorrelation vs. stable fit with static model
c(st.fit.ac$AICc, st.fit1$AICc)
#stable fit with autocorrelation vs. stable fit with static model
c(st.fit.ac$BIC,st.fit1$BIC)

#stable fit with autocorrelation vs. stable fit with static model - AIC model weights
model_weights(c(st.fit.ac$AICc,st.fit1$AICc),form='TMB')
#stable fit with autocorrelation vs. stable fit with static model - BIC model weights
model_weights(c(st.fit.ac$BIC,st.fit1$BIC),form='TMB')

```

***brief section summary paragraph here?***

## Continuous change

The key Ricker model parameters that dictate population dynamics emerge as the integration of several demographic processes - namely survival (at all life stages) and reproductive output. The intrinsic productivity parameter, $log(\alpha)$ represents the density-independent portion, while the capacity parameter $S_{max}$ represents the density-dependent portion. In nature, both of these processes may change through time in tandem with ecosystem conditions - e.g. abiotic environment, predator/prey/competitor abundances, habitat availability, etc. When these parameters shift through time, this results in 'nonstationary' population dynamics.

One way to model nonstationary dynamics is by letting the parameters themselves evolve through time - this is often termed a 'state-space' process. For example, if we let intrinsic productivity vary through time ($log(\alpha)_t$) the revised nonstationary Ricker model would look like this:

$$log(R_t/S_t) = log(\alpha)_t - S_t/S_{max} + \epsilon_t$$

$$log(\alpha)_t = log(\alpha)_{t-1} + \omega_{t}$$

$$\omega_{t} \sim N(0, \sigma_{\omega})$$

$$\epsilon_t \sim N(0, \sigma)$$

In this formulation, nonstationary productivity changes for each brood cohort $t$ based on the last years estimate ($t-1$) adjusted with some process noise ($\omega_{t}$) that is drawn from a normal distribution with a standard deviation of ($\sigma_{\omega}$; we can call this process deviance or variance). This portion of the model is equivalent to a 'random walk' or Brownian motion model, that is widely used across fields. Its application to spawner-recruit dynamics was pioneered by Dr. Randall Peterman in a series of papers - so this particular formulation has now been dubbed 'Peterman's productivity method'.


An alternative form of this would allow the capacity parameter ($S_{max}$) to instead vary through time:

$$log(R_t/S_t) = log(\alpha) - S_t/S_{max,t} + \epsilon_t$$

The key challenge in these models is that there are now two sources of variance in year-to-year $log(R_t/S_t)$ that arise from both 'low frequency' (i.e. it changes gradually through time) process error ($\sigma_{\omega}$) and 'high frequency' (i.e. it changes rapidly through time - as 'white noise') annual error ($\sigma_{\omega}$) - the latter of which emerges from both sampling effects (i.e. measurement errors in recruits and spawners) as well as true variances in demographic processes among brood cohorts.

These nonstationary models can be fit in `samEst` using the `ricker_rw_TMB()` or `ricker_rw_stan()` functions. To choose between productivity or capacity changes, one must specify the time-varying parameter (`tv.par` as `a` or `b`); one can technically specify `both`, but we discourage this for reasons we will discuss.

We will test how well these models can actually capture trend trends in these Ricker parameters using another simulation function made for this workshop - here we can change either intrinsic productivity or capacity to time-varying by specifying `par = a` or `par = b` in this function.

In this first simulation, we will develop spawner-recruit dynamics under a linear change in $\alpha$ and see if we can successfully estimate these changes with the non-stationary (random walk) version of the Ricker model. Here in productivity:

```{r, tv sim - linear prod}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.5 #proprtional change in time-varying parameter, -0.5 = -50% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.lin.prod=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,tv.par='a',tv.form='linear')

ns.prod.fit1=ricker_rw_TMB(data=df.lin.prod,tv.par='a',silent=T)
#ns.prod.fit1=ricker_rw_stan(data=df.lin.prod,tv.par='a')

#estimate in red
plot(df.lin.prod$loga.t,type='l',lwd=2,ylab='log(alpha) parameter',xlab='simulation year',ylim=c(min(c(ns.prod.fit1$logalpha,df.lin.prod$loga.t)),max(c(ns.prod.fit1$logalpha,df.lin.prod$loga.t))))
lines(ns.prod.fit1$logalpha,lwd=2,col='darkred') #predicted

```

How well does the estimate (red) approximate the true parameter (black) change? 

Note - under certain conditions it may fail to fit, either you can try the Stan version (which tends to be more flexible), or simply by re-running the simulated dataset. Regardless, try re-running the above code to see the diversity of estimates one may get in any particular run under the same parameter sets.

You can visualize the spawner-recruit curve fit using the `samEst` function, `rw_sr_plot()`:

```{r, rw sr plot - prod, fig.width=7,fig.height=9}
rw_sr_plot(data=df.lin.prod,mod=ns.prod.fit1)
```

Next we can try capacity change:

```{r, tv sim - linear smax}
#Ricker parameters
log.a0=1.5 #static productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.lin.smax=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,tv.par='b',tv.form='linear')

ns.smax.fit1=ricker_rw_TMB(data=df.lin.smax,tv.par='b',silent=T)
#ns.smax.fit1=ricker_rw_stan(data=df.lin.smax,tv.par='b')

plot(df.lin.smax$smax.t,type='l',lwd=2,ylab='Smax parameter',xlab='simulation year',ylim=c(min(c(ns.smax.fit1$Smax,df.lin.smax$smax.t)),max(c(ns.smax.fit1$Smax,df.lin.smax$smax.t))))
lines(ns.smax.fit1$Smax,lwd=2,col='darkred') #predicted
```

```{r, rw plot smax,fig.width=6,fig.height=8}
rw_sr_plot(data=df.lin.smax,mod=ns.smax.fit1)
```

Does this track better or worse than the productivity change estimate?

### Nonlinear directional change  

The previous examples are illustrative of a very basic hypothesis for system changes (i.e. linear directional change), in reality the processes driving nonstationary dynamics are likely to be much more temporally complex - we can try out some more realistic scenarios by generating the same datasets with a random walk in the nonstationary parameter, which matches the model estimation form directly. Each iteration should be quite different so keep re-running and estimating to see the diversity of trajectories you can generate.

```{r, tv sim - random walk prod}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.rw.prod=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,tv.par='a',tv.form='rw')

ns.prod.fit3=ricker_rw_TMB(data=df.rw.prod,tv.par='a',silent=T)
#ns.prod.fit3=ricker_rw_stan(data=df.rw.prod,tv.par='a')

plot(df.rw.prod$loga.t,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year',ylim=c(min(c(df.rw.prod$loga.t,ns.prod.fit3$logalpha)),max(c(df.rw.prod$loga.t,ns.prod.fit3$logalpha))))
lines(ns.prod.fit3$logalpha,lwd=2,col='darkred') #predicted change
```

Now we will try the random walk change on capacity:

```{r, tv sim - random walk smax}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.5#proprtional change in time-varying parameter, -0.5 = -50% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.rw.smax=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,tv.par='b',tv.form='rw')

ns.smax.fit3=ricker_rw_TMB(data=df.rw.smax,tv.par='b',silent=T)
#ns.smax.fit3=ricker_rw_stan(data=df.rw.smax,tv.par='b')

plot(df.rw.smax$smax.t,type='l',lwd=2,ylab='Smax parameter',xlab='simulation year',ylim=c(min(c(df.rw.smax$smax.t,ns.smax.fit3$Smax)),max(c(df.rw.smax$smax.t,ns.smax.fit3$Smax))))
lines(ns.smax.fit3$Smax,lwd=2,col='darkred')

```

In real time-series of salmon spawner-recruit dynamics, we won't know which parameter is actually nonstationary (if any). Let's apply our estimates to the alternate simulation to see what it estimates (note - the simulation datasets are switched to be mismatched):

```{r, tv est - linear crossed,fig.width=6,fig.height=8}
ns.prod.fit2=ricker_rw_TMB(data=df.lin.smax,tv.par='a',silent=T)

ns.smax.fit2=ricker_rw_TMB(data=df.lin.prod,tv.par='b',silent=T)

par(mfrow=c(2,1))
plot(ns.prod.fit2$logalpha,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year',col='darkred')
lines(df.lin.smax$loga.t,lwd=2) #true prod change
plot(ns.smax.fit2$Smax,type='l',lwd=2,ylab='Smax parameter',xlab='simulation year',col='darkred')
lines(df.lin.prod$smax.t,lwd=2) #true prod change

```

You will notice that estimates of nonstationary productivity and capacity tend to follow the same statistical signal in the time-series, a change in productivity can look like a change in capacity and vice-versa - even though the implied system dynamics are quite different.


### Model selection  

Similar to our example comparing autocorrelation and stable dynamics, perhaps we can use model selection to detect the true underlying parameter?

Nonstationary productivity:  
```{r, tv est - linear crossed mod sel - prod scenario}
#tv-productivity generating data - tv productivity and tv smax fit
c(ns.prod.fit1$AICc, #prod est matched to prod data
ns.smax.fit2$AICc) #smax est matched to prod data

#identifying prod vs capacity change in true productivity change
model_weights(c(ns.prod.fit1$AICc,ns.smax.fit2$AICc),form='TMB')
```

Nonstationairy capacity:  
```{r, tv est - linear crossed mod sel - smax scenario}
#tv-smax generating data - tv productivity and tv smax fit
c(ns.prod.fit2$AICc, #prod est matched to prod data
ns.smax.fit1$AICc) #smax est matched to prod data

#identifying prod vs capacity change in true productivity change
model_weights(c(ns.prod.fit2$AICc,ns.smax.fit1$AICc),form='TMB')
```

Were you able to correctly identify the true parameter changes based on the model likelihood and selection criteria?

## Regime shifts

In some cases, the form of nonstationarity may be much more abrupt than what we've previously simulated and modeled- and this may especially be true for Pacific salmon where oceanographic climate appears to have a large influence on population dynamics and can rapidly shift between phases over periods of time.

Another nonstationary model form tries to capture these 'regime shift' dynamics using a hidden Markov model (HMM) framework. The HMM is a tool to measure 'hidden states' that governs a system's dynamics. In our case we may expect that there are potentially 2 (or more) regimes that dictate salmon population dynamics: a low productivity and high productivity state. Since we do not necessarily know which state we are in at a given time point we model the probability of being in any given state over time.

We won't get into the detailed statistics behind the HMM for this, but in basic terms the model works by having $k$=2 (or more) governing system parameter states (e.g. 2 estimates of $log(\alpha)$, or ($S_{max}$, or both) and estimates of a $k$x$k$ transition matrix:  

|           |           |
|:---------:|:---------:|  
| $p_{1,1}$ | $p_{1,2}$ |  
| $p_{2,1}$ | $p_{2,2}$ |  

This transition matrix contains the estimated probabilities of either staying ($p_{1,1}$ and $p_{2,2}$) or shifting ($p_{1,2}$ and $p_{2,1}$) from one state to another for each time-step in a time-series, where $p_{1,2}$ is the probability of shifting from state 1 to state 2. In practice, this results in some inertia or latency that expects system dynamics to stay in a given regime for several years at a time before eventually transitioning to the other state - recreating the sort of regime shift dynamics we would expect to occur in a natural system.

We can fit the HMM variant of the Ricker model using `samEst` functions `ricker_hmm_TMB()` and `ricker_hmm_stan()`.

We can test these out by simulating known regime-like dynamics and fitting the models as the previous sections. You can adjust the number of potential regime states with `k_regime`. ***Typically***

```{r, prod regime hmm}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.5#proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.reg.prod=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,tv.par='a',tv.form='regime',reg.length=8)

hmm.fit.prod=ricker_hmm_TMB(data=df.reg.prod,tv.par='a',k_regime=2,silent=T)

```

The productivity estimates from the different regime states:
```{r, regime log a}
hmm.fit.prod$logalpha
```

We can pull up the estimated transition matrix from the fitted model as `$qij`:

```{r, transition matrix}
hmm.fit.prod$qij
```

The first number *1,1* is the probability, when in regime 1 (low productivity regime) of staying in that regime from year-to-year, while *1,2* is the probability of exiting that regime. The opposite elements, *2,1* and *2,2*, correspond to leaving or staying in regime 2 (high productivity) - each row the probabilities sum to 1.

We can extract time-series of both the probability of being in each regime through time (`probregime`), as well as the most likely regime (`regime`) at each time point as outputs of the model:

```{r, regime time-series}
round(hmm.fit.prod$probregime,2)

hmm.fit.prod$regime
```

We can compare this to our simulated dynamics as previously.

```{r, prod regime true vs estimated}
plot(df.reg.prod$loga.t,type='l',lwd=2,ylim=c(min(c(df.reg.prod$loga.t,hmm.fit.prod$logalpha)),max(c(df.reg.prod$loga.t,hmm.fit.prod$logalpha))))
lines(hmm.fit.prod$logalpha[hmm.fit.prod$regime],lwd=2,col='darkred') #predicted state

```

Another way to visualize this is to multiply the probability of each regime by its expected parameter (in red) - this (often) ends up being conceptually similar to the random walk (in blue):

```{r, prod regime continuous}
hmm.fit.prod$logalpha.t=hmm.fit.prod$logalpha%*%hmm.fit.prod$probregime

rw.fit.reg=ricker_rw_TMB(data=df.reg.prod,tv.par='a',silent=T)

plot(df.reg.prod$loga.t,type='l',lwd=2,ylim=c(min(c(df.reg.prod$loga.t,hmm.fit.prod$logalpha.t,rw.fit.reg$logalpha)),max(c(df.reg.prod$loga.t,hmm.fit.prod$logalpha.t,rw.fit.reg$logalpha))),ylab='productivity through time')
lines(as.numeric(hmm.fit.prod$logalpha.t),lwd=2,col='darkred') #predicted state
lines(rw.fit.reg$logalpha,lwd=2,col='navy') #predicted state * probibility 
```

What you probably will find is that estimates from models do not perfectly replicate the simulating dynamics - sometimes misidentifying the true regime or being a lagged indicator. Much of this emerges due to the stochastic nature of recruitment where it can struggle to differentiate noise from the underlying dynamics.

For the regime shift models, we can also allow both productivity and capacity to differ between regimes - allowing for a lot of flexibility. This could emerge when conditions shift in such a way that both density-dependent and -independent survival are affected.

The `samEst` plotting function `hmm_sr_plot()` will show the $k$ estimate spawner-recruit curves, with the observations being colourized based on their probability of emerging from each curve (or regime) - with estimates of probabilities through time as the adjacent plot.

```{r, prod-cap regime hmm,fig.height=8,fig.width=6}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.5#proprtional change in productivity, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
p.change2=-0.5#proprtional change in capacity, -0.75 = -75% (on the log-scale), 0.5 = +50%

sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.reg.b=salmon_sim.tv(log.a0=log.a0,p.change=p.change,p.change2=p.change2,smax0=smax0,sigma=sigma,N=N,tv.par='both',tv.form='regime',reg.length=8)

hmm.fit.b=ricker_hmm_TMB(data=df.reg.b,tv.par='both',k_regime=2,silent=T)

hmm_sr_plot(data=df.reg.b,mod=hmm.fit.b)
```

```{r, prod cap regime true vs estimated,fig.height=9,fig.width=7}
par(mfrow=c(2,1))
plot(df.reg.b$loga.t,type='l',lwd=2,ylim=c(min(c(df.reg.b$loga.t,hmm.fit.b$logalpha)),max(c(df.reg.b$loga.t,hmm.fit.b$logalpha))),ylab='productivity',xlab='year')
lines(hmm.fit.b$logalpha[hmm.fit.b$regime],lwd=2,col='darkred')
plot(df.reg.b$smax.t,type='l',lwd=2,ylim=c(min(c(df.reg.b$smax.t,hmm.fit.b$Smax)),max(c(df.reg.b$smax.t,hmm.fit.b$Smax))),ylab='Smax',xlab='year')
lines(hmm.fit.b$Smax[hmm.fit.b$regime],lwd=2,col='darkred')
```

# Empirical examples

In this section, we will provide you with various real spawner-recruit time-series so that you can explore their potential for non-stationarity using the tools from the previous sections.

## Fraser Sockeye

## Bristol Bay Sockeye

## Harrison Chinook

## 