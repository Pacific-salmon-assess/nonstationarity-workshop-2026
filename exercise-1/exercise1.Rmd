---
title: 'Exercise 1: Assessing nonstationarity in spawner-recruit dynamics'
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Overview

The following exercises are intended to give participants a broad understanding of the statistical nuances of estimating nonstationarity in spawner-recruit time-series, with practical applications using the *samEst* package. You may choose to 'knit' this document to an HTML file, for visualization - or simply read through the text here. We encourage you to modify the R code chunks to experiment with each section.

# Forms of non-stationarity, and its alternatives

Non-stationarity in the context of spawner-recruit dynamics refers to system parameters (ie. max. recruitment, $log(\alpha)$, density-dependence, $\beta$ or $S_{max}$, or even recruitment variability, $\sigma$) that change through time rather than act as static or stable parameters that govern system dynamics.

To start let's consider the standard Ricker logistic model of population dynamics:

$R_t = S_t \cdot e^{\alpha - \beta \cdot S_t + \epsilon_t}$

$\epsilon_t \sim N(0, \sigma)$

Where $R_t$ is the abundance of adult recruits for brood cohort at year $t$, $S_t$ is the parent spawning abundance in brood cohort year $t$, $\alpha$ is the intrinsic productivity representing maximum adult recruit produced per spawning parent (at theoretical $S_t$ = 0, since it is an intercept), $\beta$ is the per-capita reduction in recruitment per spawning parent - and $S_{max}$ is the inverse of this quantity (representing the spawning abundance where total recruitment is maximized), $\epsilon_t$ is a normal deviate (but log-normal on the real scale of recruitment) representing deviance (or noise; represented by the scale or standard deviation parameter, \sigma) in the recruitment process for that brood cohort year from the system parameters expectation.

This equation can be linearized, with some rearrangement of the terms, which is how we will fit this in practice - as it then becomes a standard linear regression, in terms of $log(R_t/S_t)$:

$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$

Note that we have substituted $S_{max}$ for $\beta$ from the previous equation, because 1) $S_{max}$ is a biologically meaningful parameter and 2) this is the formulation used in *samEst*.

Let's begin to explore this model with some real-world examples. Below you will find sections with numerous example datasets.

## Stable (or static, or equilibrium) dynamics

Let's begin by visualizing the sort of spawner-recruit time-series one may obtain from this model - when parameters are stable through time. We will do this through simulated data - we will use a Pink salmon life cycle, mostly for convenience as due to their fixed life history the recruits are equivalent to the run size in each year so we can ignore the added complexity of variable ages. In real-world data for most other species, the recruits by brood cohort must be back-calculated using run sizes (e.g. spawning abundance + total harvest abundance in a given year) and age distributions (ideally for each year - and separately for spawning and catch (and even perhaps more fine-scale to each fishery), in a perfect world).

Feel free to adjust the parameters in the Ricker/simulation sections to see how it changes both the shape of the expected curve and the spawner-recruit series. To get a sense of some real-world distributions of the key parameters you can view some empirical distributions from a meta-analsyis of spawner-recruit dynamics here:

```{r, functions,echo=FALSE}
source('../exercise-1/sim_functions.R')
```

```{r, static ricker simulation,fig.width=6,fig.height=8}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from... ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

#For this workshop, we've made a function to simulate spawner-recruit dynamics, if you are very keen you can dig into it in the above function R file. The main inputs for this function currently
df.st=salmon_sim(log.a=log.a,smax=smax,sigma=sigma,N=N,form='static')

#visualize your simulated time-series
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #Spawner Recruit curve
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)
plot(df.st$logRS~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),xlab='spawners',ylab='log(R/S)') #Spawner Recruit curve
pred2=log.a-S_p/smax
lines(pred2~S_p,lwd=2)


```
Try changing the key Ricker parameters and note how the spawner-recruit curve shifts in kind.


Next we will use *samEst* functions to estimate this model from the simulated spawner-recruit time-series.

There are two forms for model fitting that we included in this package - one using *Template Model Builder* (*TMB*), which uses Laplace approximation of the marginal likelihood to estimate parameter values (i.e. maximum likelihood estimates, MLE), the other form is a Bayesian method using *Stan*. We won't get into great detail about all the nuances of the theory and practice of these two model forms, but the main point for their implmentation in *samEst* is that the former will give fast point estimates and has an option for no priors on the parameters, while the latter will give full posteriors where it's easier to work with the full uncertainty of the parameters and also requires priors on each parameter.

For the stationary form of the Ricker model, the two functions are: *ricker_TMB* and *ricker_stan*. You can call up either function (e.g. *??ricker_TMB*) to see the available arguments. For the rest of this exercise, we will use the *TMB* versions for speed and ease, you are welcome to switch to stan implementations and see the final section of advanced options for those interested.

Fit the TMB estimate of the Ricker curve with *samEst*:

```{r, static ricker estimation, TMB,fig.width=6,fig.height=4}
library(samEst)
#ricker_TMB requires data-frame or list with S = a vector of spawning abundances, and logRS = a vector of log(recruits/spawner)

tmb.fit1=ricker_TMB(data=df.st,silent=T,priors_flag = 0)#note silent = T just surpresses the updates on the likelihood gradient, and priors_flag = 0 will turn off priors on Ricker parameters
```

How do the estimates compare to the true values in the simulation?

```{r, static estimates comp.}

#We can view the MLE estimates of the key parameters by calling them up from the function:
log.a
tmb.fit1$logalpha
smax
tmb.fit1$Smax
sigma
tmb.fit1$sig
```
Let's visualize the estimation prediction (red) compared to true (black):

```{r, static ricker estimation, TMB,fig.width=6,fig.height=4}
#compare the estimated curve to the true curve:
plot(R~S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(S)),ylim=c(0,max(R))) #Spawner Recruit curve
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)
pred.est=exp(tmb.fit1$logalpha-S_p/tmb.fit1$Smax)*S_p
lines(pred.est~S_p,col='darkred',lwd=2)

```

You may find the estimated vs. true Ricker curves are slightly off - but largely in the same realm. The more important aspect is whether the key biological reference points - e.g. spawners that maximize sustainable yield ($S_{msy}$) or the harvest rate at maximum sustainable yield ($U_{msy}$) - are close enough, as these are the management quantities that we're hoping to derive from these curves. These can be calculated directly from the Ricker parameters as:


$S_{msy} = (1 - LambertW(e^{1-log(\alpha)}))/\beta$

$U_{msy} = 1 - LambertW(e^{1-log(\alpha)})$

In *samEst*, these can be implemented via *smsyCalc* and *umsyCalc*, but these are also standard outputs that are generated from the estimated functions (e.g. *ricker_TMB*).

```{r, static ricker ref pt estimation, TMB}
true.smsy=smsyCalc(log.a,b=1/smax)
true.smsy #true smsy

tmb.fit1$Smsy #estimated smsy

true.umsy=umsyCalc(log.a)
true.umsy

tmb.fit1$umsy

```

The previous example is sort of idealized, in the sense that (beyond being a stable system) you as an analyst have perfect data - i.e. the estimates of recruits and spawners are known quantities - since we simulated them. In reality, sampling error in these quantities (i.e. in escapement estimates, catch, and age distributions) can be considerable. We can add in some simple white noise sampling error to see how this affects our recovery of the Ricker parameters.

```{r, static ricker sampling error }
#we can add some noise to each state variable to get closer to an observed quantity
cv.r=0.25 #this sets the 'coefficient of variation', which is the standard deviation scaled to the mean
cv.s=0.25
R_obs=rnorm(length(R),R,cv.r*R)
R_obs=ifelse(R_obs<0,1,R_obs) #in case you get negative values
S_obs=rnorm(length(S),S,cv.s*S)
S_obs=ifelse(S_obs<0,1,S_obs)

logRS_obs=log(R_obs/S_obs)

df2=data.frame(S=S_obs,logRS=logRS_obs)
tmb.fit2=ricker_TMB(data=df2)

plot(R~S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(S)),ylim=c(0,max(R))) #Spawner Recruit curve
points(R_obs~S_obs,pch=21,bg=adjustcolor('darkred',alpha.f=0.5),col='transparent')
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)
pred.est=exp(tmb.fit2$logalpha-S_p/tmb.fit2$Smax)*S_p
lines(pred.est~S_p,col='darkred',lwd=2)
```
Check how this may or may not change the key parameters and reference points in the estimated fit.


## Stable, but autocorrelated, recruitment dynamics

The previous example is the sort of idealized scenario one would hope for a real population - stable dynamics over a long period - with normally distributed fluctuations in year-to-year production (ie. log(R/S)). In reality, many fish populations, including Pacific salmon, have autocorrelated variation in recruitment dynamics - that is production tends to self-similar from year-to-year resulting in strings of good or bad years for recruitment. This likely arises from environmental conditions that tend to be self-similar (e.g. temperature, bottom-up productivity, etc.). We can revise the static model to include this autocorrelation in recruitment variance:

$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$

$\epsilon_t = \rho \cdot \epsilon_{t-1}  + \sqrt{1-\rho^{2\Delta t}}\cdot \delta_t$

$\delta_t \sim N(0, \sigma)$

The key difference here is that the annual recruitment deviance $\epsilon_t$ now includes both a random annual fluctuation ($delta_t$) and a 1-year lagged autocorrelation term ($\rho \cdot \epsilon_{t-1}$) where the level of autocorrelation ($\rho$) dictates the 'memory' in system dynamics.

We will add this to our simulated stable dynamics to see how it changes the spawner-recruit curve and parameter estimates. 

```{r, autocorrelated stable dynamics}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from... ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
K = log.a*smax #carrying capacity, aka Seq (equilibrium spawners), the stable attraction point
rho = 0.8 #autocorrelation parameter - the scale of 'memory' in recruitment deviations

#age structure
#this accounts for different maturations as is typical for most salmon species
A=5 #max age class
age=c(3,4,5) #ages at return - set to 3,4,5
age.p=c(0.25,0.5,0.25) # proportions returning at each age class = note if modifying this, it must sum to 1. This is fixed in this example to keep things simple but one could vary with some noise from year-to-year using e.g. dirichlet distribution

#simulation parameters
N=50 #number of simulated years to the future
L=N+A*2 #total length, add 2x max age for starting cohorts to seed the simulation and for final incomplete brood years
U=runif(L,0.2,0.8) #harvest rate - uniformly drawn (you can change this but be careful of exceeding, 0-1 boundaries)
#U=plogis(normal(L,0,0.5)) - alternative harvest rate protocol using a logit-transformed normal draw, less variable than above, can comment the above line with # and this off to switch 

#simulation vectors
logRS=numeric(L) #productivity, log(R/S), for each brood cohort
S=numeric(L);S[1:c(A)]=runif(A,K*0.25,K*1.5) #initial spawners, randomized between 0.5-1.5*K 
R=numeric(L) #recruits in each brood cohort year
Rs=numeric(L) #run size, ie. the returning abundance in each year (recruits x age structure)
eps=numeric(L) #residual productivity - epsilon

#first recruitments and run sizes from randomized spawners to initialize simulation
#first draw has no autocorrelation, all subsequent draws will include the autocorrelation component
logRS[1]=rnorm(1, mean=(log.a - S[1]/smax),sd=sigma)
eps[1]=logRS[1]-(log.a - S[1]/smax) #first residual, realized log(R/S) minus expected (mean) log(R/S)
for(t in 2:A){ #all subsequent have expectation shifted by rho*eps[t-1]
  logRS[t]=rnorm(1, mean=(log.a - S[t]/smax + rho*eps[t-1]),sd=sigma)
  eps[t]=logRS[t]-(log.a - S[t]/smax)
}
R[1:c(A)]=exp(logRS[1:c(A)])*S[1:c(A)] #transform to recruits by converting log(R/S) to R/S times spawners
for(t in 1:c(A)){ #initialize first 2 generations of run sizes
   for(a in 1:length(age)){
    Rs[t+age[a]]=Rs[t+age[a]]+R[t]*age.p[a] #add proportion of recruits by age class
  }
}
#this has setup the the initial run sizes for the simulation

for(t in c(A+1):c(L-A)){ #from years max age + 1
  #for each year, we will harvest the run, get the remaining spawning abundance
  S[t]=Rs[t]*(1-U[t]) # spawning abundance (escapement) is run size minus harvest rate
  
  #recruitment for this brood cohort (year t) - mean is equal to the expectation from the ricker model based on input parameters
  logRS[t]=rnorm(1, mean=(log.a - S[t]/smax+ rho*eps[t-1]),sd=sigma)
  eps[t]=logRS[t]-(log.a - S[t]/smax)
  #convert to number of recruits for brood cohort
  R[t]=exp(logRS[t])*S[t]
  
  #stagger recruits into future run sizes based on age maturation schedule:
  for(a in 1:length(age)){
    Rs[t+age[a]]=Rs[t+age[a]]+R[t]*age.p[a]
  }
}
#We'll trim out the initialization period (first generation) and last generation (incomplete cohorts)
S=S[c(A+1):c(L-A)]
R<-R[c(A+1):c(L-A)]
logRS<-logRS[c(A+1):c(L-A)]
eps<- eps[c(A+1):c(L-A)]

df.ac=data.frame(S=S,R=R,logRS=logRS,eps=eps) #the data inputs for each function 
```

Let's visualize this SR curve and the residuals through time - to highlight the time-series element of recruitment dynamics we'll colour code observations by year of the simulation.

```{r, autocorrelated SR plot,fig.width=6,fig.height=8}
#
par(mfrow=c(2,1))
plot(df.ac$R~df.ac$S,bty='l',type='n',xlim=c(0,max(df.ac$S)),ylim=c(0,max(df.ac$R)),xlab='spawners',ylab='recruits') #Spawner Recruit curve
points(df.ac$R~df.ac$S,pch=21,bg=viridis::viridis(length(S)))
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.ac$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)

plot(df.ac$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(eps,pch=21,bg=viridis::viridis(length(S)))

```
Lets's compare this to the same system with no autocorrelation (note if you changed the ricker parameters in the previous section these will not be directly comparable) - also assumes you've ran the section defining df.st

```{r, stable dynamics comp plot, fig.width=6,fig.height=8}
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',type='n',pch=21,xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #Spawner Recruit curve
points(df.st$R~df.st$S,pch=21,bg=viridis::viridis(length(S)))
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)

plot(df.st$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(df.st$eps,pch=21,bg=viridis::viridis(length(S)))
```

What do you notice about the temporal patterns in the residuals?

Let's see how this effects parameter estimates. To account for autocorrelation in our estimation models, we set the *AC* option in *ricker_TMB* or *ricker_stan* to *TRUE*.

First let's see how it performs on the autocorrelated dataset:

```{r, ac estimates 1}
#f
ac.tmbfit1=ricker_TMB(data=df.ac,AC=TRUE,silent=T)

rho
ac.tmbfit1$rho
smax
ac.tmbfit1$Smax
log.a
ac.tmbfit1$logalpha

```
What if we don't account for autocorrelation, what parameters will we get?

```{r, ac estimates 3}
ac.tmbfit3=ricker_TMB(data=df.ac,AC=FALSE,silent=T)

rho
ac.tmbfit3$rho
smax
ac.tmbfit3$Smax
log.a
ac.tmbfit3$logalpha

```

Will it be able to detect autocorrelation in the entirely stable dataset?

```{r, ac estimates 2}
ac.tmbfit2=ricker_TMB(data=df.st,AC=TRUE,silent=T)

rho
ac.tmbfit2$rho
smax
ac.tmbfit2$Smax
log.a
ac.tmbfit2$logalpha
```


