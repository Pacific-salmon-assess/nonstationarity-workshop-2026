---
title: 'Exercise 1: Assessing nonstationarity in spawner-recruit dynamics'
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Overview

The following exercises are intended to give participants a broad understanding of the statistical nuances of estimating nonstationarity in spawner-recruit time-series, with practical applications using the *samEst* package. You may choose to 'knit' this document to an HTML file, for visualization - or simply read through the text here. We encourage you to modify the R code chunks to experiment with each section.

# Forms of non-stationarity, and its alternatives

Non-stationarity in the context of spawner-recruit dynamics refers to system parameters (ie. max. recruitment, $log(\alpha)$, density-dependence, $\beta$ or $S_{max}$, or even recruitment variability, $\sigma$) that change through time rather than act as static or stable parameters that govern system dynamics.

To start let's consider the standard Ricker logistic model of population dynamics:

$R_t = S_t \cdot e^{\alpha - \beta \cdot S_t + \epsilon_t}$

$\epsilon_t \sim N(0, \sigma)$

Where $R_t$ is the abundance of adult recruits for brood cohort at year $t$, $S_t$ is the parent spawning abundance in brood cohort year $t$, $\alpha$ is the intrinsic productivity representing maximum adult recruit produced per spawning parent (at theoretical $S_t$ = 0, since it is an intercept), $\beta$ is the per-capita reduction in recruitment per spawning parent - and $S_{max}$ is the inverse of this quantity (representing the spawning abundance where total recruitment is maximized), $\epsilon_t$ is a normal deviate (but log-normal on the real scale of recruitment) representing deviance (or noise; represented by the scale or standard deviation parameter, \sigma) in the recruitment process for that brood cohort year from the system parameters expectation.

This equation can be linearized, with some rearrangement of the terms, which is how we will fit this in practice - as it then becomes a standard linear regression, in terms of $log(R_t/S_t)$:

$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$

Note that we have substituted $S_{max}$ for $\beta$ from the previous equation, because 1) $S_{max}$ is a biologically meaningful parameter and 2) this is the formulation used in *samEst*.

Let's begin to explore this model with some real-world examples. Below you will find sections with numerous example datasets.

## Stable (or static, or equilibrium) dynamics

Let's begin by visualizing the sort of spawner-recruit time-series one may obtain from this model - when parameters are stable through time. We will do this through simulated data - we have made a function to simulate a generic Pacific salmon life cycle, in this case where fish return at ages 3, 4, or 5. We mimic the real world by creating annual run sizes from the total recruits spawned by each brood cohort, allow for harvest on the run (in this case, the harvest is just random irrespective of run size - but later we will allow for more realistic harvest control rules), and the 'escapement' of the run becomes the spawners for that year's brood cohort (and the cycle continues...).

The simulation is governed by our familiar Ricker parameters ($log(\alpha)$,$S_{max}$,$\sigma$), as well as an option to change the time-series length ($N$). Feel free to alter these parameters and see the resulting changes to the simulated datasets. To get a sense of some real-world distributions of the key parameters you can view some empirical distributions from a meta-analsyis of spawner-recruit dynamics here:

```{r, simulation functions,echo=FALSE}
source('../exercise-1/sim_functions.R')
```

```{r, static ricker simulation,fig.width=6,fig.height=8}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from... ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

#For this workshop, we've made a function to simulate spawner-recruit dynamics, if you are very keen you can dig into it in the above function R file. The main inputs for this function currently
df.st=salmon_sim(log.a=log.a,smax=smax,sigma=sigma,N=N,form='static')

#visualize your simulated time-series
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #Spawner Recruit curve
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)
plot(df.st$logRS~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),xlab='spawners',ylab='log(R/S)') #Spawner Recruit curve
pred2=log.a-S_p/smax
lines(pred2~S_p,lwd=2)


```
Try changing the key Ricker parameters and note how the spawner-recruit curve shifts in kind.


We will use various *samEst* functions to estimate this model (and others) from the simulated spawner-recruit time-series.

There are two forms for model fitting that we included in this package - one using *Template Model Builder* (*TMB*), which uses Laplace approximation of the marginal likelihood to estimate parameter values (i.e. maximum likelihood estimates, MLE), the other form is a Bayesian method using *Stan*. We won't get into great detail about all the nuances of the theory and practice of these two model forms, but the main point for their implmentation in *samEst* is that the former will give fast point estimates and has an option for no priors on the parameters, while the latter will give full posteriors where it's easier to work with the full uncertainty of the parameters and also requires priors on each parameter.

For the stationary form of the Ricker model, the two functions are: *ricker_TMB* and *ricker_stan*. You can call up either function (e.g. *??ricker_TMB*) to see the available arguments. For the rest of this exercise, we will use the *TMB* versions for speed and ease, you are welcome to switch these to *Stan* implementations, see the final section of advanced options for those interested.

Fit the TMB estimate of the Ricker curve with *samEst*. Note that we will turn off priors on the parameters (you are welcome to experiment with turning them on to experiment with how this shapes outcomes however).

```{r, static ricker estimation TMB,fig.width=6,fig.height=4}
library(samEst)
#ricker_TMB requires data-frame or list with S = a vector of spawning abundances, and logRS = a vector of log(recruits/spawner)

tmb.fit1=ricker_TMB(data=df.st,silent=T,priors_flag = 0)#note silent = T just surpresses the updates on the likelihood gradient, and priors_flag = 0 will turn off priors on Ricker parameters
```

How do the estimates compare to the true values in the simulation?

```{r, static estimates comp.}

#We can view the MLE estimates of the key parameters by calling them up from the function:
log.a
tmb.fit1$logalpha
smax
tmb.fit1$Smax
sigma
tmb.fit1$sig
```
Let's visualize the estimation prediction (red) compared to true (black):

```{r, static ricker estimation plot,fig.width=6,fig.height=4}
#compare the estimated curve to the true curve:
plot(df.st$R~df.st$S,bty='l',pch=21,bg=adjustcolor('black',alpha.f=0.5),xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R))) #Spawner Recruit curve
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)
pred.est=exp(tmb.fit1$logalpha-S_p/tmb.fit1$Smax)*S_p
lines(pred.est~S_p,col='darkred',lwd=2)

```

You may find the estimated vs. true Ricker curves are slightly off - but largely in the same realm. The more important aspect is whether the key biological reference points - e.g. spawners that maximize sustainable yield ($S_{msy}$) or the harvest rate at maximum sustainable yield ($U_{msy}$) - are close enough, as these are the management quantities that we're hoping to derive from these curves. These can be calculated directly from the Ricker parameters as:

$S_{msy} = (1 - LambertW(e^{1-log(\alpha)}))/\beta$

$U_{msy} = 1 - LambertW(e^{1-log(\alpha)})$

In *samEst*, these can be implemented via *smsyCalc* and *umsyCalc*, which we will apply to our true known parameters - but these are also standard outputs that are generated from the estimated functions (e.g. *ricker_TMB*).

```{r, static ricker ref pt estimation, TMB}
true.smsy=smsyCalc(log.a,b=1/smax)
true.smsy #true smsy

tmb.fit1$Smsy #estimated smsy

true.umsy=umsyCalc(log.a)
true.umsy

tmb.fit1$umsy

```

## Stable, but autocorrelated, recruitment dynamics

The previous example is the sort of idealized scenario one would hope for a real population - stable dynamics over a long period - with normally distributed fluctuations in year-to-year production (ie. log(R/S)). In reality, many fish populations, including Pacific salmon, have autocorrelated variation in recruitment dynamics - that is production tends to self-similar from year-to-year resulting in strings of good or bad years for recruitment. This likely arises from environmental conditions that tend to be self-similar (e.g. temperature, bottom-up productivity, etc.). We can revise the static model to include this autocorrelation in recruitment variance:

$log(R_t/S_t) = log(\alpha) - S_t/S_{max} + \epsilon_t$

$\epsilon_t = \rho \cdot \epsilon_{t-1}  + \sqrt{1-\rho^{2\Delta t}}\cdot \delta_t$

$\delta_t \sim N(0, \sigma)$

The key difference here is that the annual recruitment deviance $\epsilon_t$ now includes both a random annual fluctuation ($delta_t$) and a 1-year lagged autocorrelation term ($\rho \cdot \epsilon_{t-1}$) where the level of autocorrelation ($\rho$, ranging from -1 to 1) dictates the 'memory' in system dynamics. Positive values of $\rho$ indicate that successive years of recruitment are more similar to each other, while negative values indicate that successive years are more dissimilar - which could emerge from strong inter-cohort competitive effects. In real spawner-recruit time-series, autocorrelation is almost always positive (see empirical estimates by species here: $\rho$$\rho$$\rho$), so we will focus on this in our simulation (but feel free to change it to negative if you're curious).

We will add this to our simulated stable dynamics to see how it changes the spawner-recruit curve and parameter estimates.

```{r, autocorrelated stable dynamics}
#Ricker parameters
log.a=1.5 #note - this parameter tends to vary from... ~0.2 to ~ 3 in real populations (use exp(x) to translate this to raw max. recruits/spawner); note at log(0) = 1, this implies essentially an extinction vortex (as all values of S_t > 0 will lead to negative expect R/S)
smax=5000 #this parameter can vary massively, from hundreds to millions
sigma=0.6 #most stocks range from ~0.3 to 1.5
K = log.a*smax #carrying capacity, aka Seq (equilibrium spawners), the stable attraction point
rho = 0.9 #autocorrelation parameter - the scale of 'memory' in recruitment deviations

df.ac=salmon_sim(log.a=log.a,smax=smax,sigma=sigma,N=N,rho=rho,form='autocorr')

```

Let's visualize this SR curve and the residuals through time - to highlight the time-series element of recruitment dynamics we'll colour code observations by year of the simulation.

```{r, autocorrelated SR plot,fig.width=6,fig.height=8}
#
par(mfrow=c(2,1))
plot(df.ac$R~df.ac$S,bty='l',type='n',xlim=c(0,max(df.ac$S)),ylim=c(0,max(df.ac$R)),xlab='spawners',ylab='recruits') 
lines(df.ac$R~df.ac$S,lwd=0.5,col=adjustcolor('darkgray',alpha.f=0.5))
#Spawner Recruit curve
points(df.ac$R~df.ac$S,pch=21,bg=viridis::viridis(length(df.ac$S)))
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.ac$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)

plot(df.ac$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(df.ac$eps,pch=21,bg=viridis::viridis(length(df.ac$S)))

```
Lets's compare this to the same system with no autocorrelation (note if you changed the ricker parameters in the previous section these will not be directly comparable, if not - re-run the previous section with equivalent Ricker parameters). Note 'eps' = $\epsilon_t$ = the residuals from the true parameters.

```{r, stable dynamics comp plot, fig.width=6,fig.height=8}
par(mfrow=c(2,1))
plot(df.st$R~df.st$S,bty='l',type='n',pch=21,xlim=c(0,max(df.st$S)),ylim=c(0,max(df.st$R)),xlab='spawners',ylab='recruits') #Spawner Recruit curve
lines(df.st$R~df.st$S,lwd=0.5,col=adjustcolor('darkgray',alpha.f=0.5))
points(df.st$R~df.st$S,pch=21,bg=viridis::viridis(length(df.st$S)))
abline(c(0,1),lty=5) #1:1 line to indicate where recruits = spawners
#expectation based on true ricker parameters:
S_p=seq(0,max(df.st$S))
pred=exp(log.a-S_p/smax)*S_p
lines(pred~S_p,lwd=2)

plot(df.st$eps,bty='l',type='l',xlab='year of simulation',ylab='residual productivity')
abline(h=0,lty=5)
points(df.st$eps,pch=21,bg=viridis::viridis(length(df.st$S)))
```

What do you notice about the temporal patterns in the residuals?

Let's see how this effects parameter estimates. To account for autocorrelation in our estimation models, we set the *AC* option in *ricker_TMB* or *ricker_stan* to *TRUE*.

First let's see how it performs on the autocorrelated dataset:

```{r, ac est - ac true}
#f
ac.fit.ac=ricker_TMB(data=df.ac,AC=TRUE,silent=T)

rho
ac.fit.ac$rho
smax
ac.fit.ac$Smax
log.a
ac.fit.ac$logalpha

```
Let's visualize the model fit, we can use the *samEst* function *static_sr_plot*:

```{r, ac estimates 1,fig.width=6,fig.height=8}
static_sr_plot(df=df.ac,mod=ac.fit.ac,plot.params=TRUE,resids=TRUE) 
```

What if we don't account for autocorrelation, what parameters will we get?

```{r, ac estimates 3,fig.width=6,fig.height=8}
ac.fit.st=ricker_TMB(data=df.ac,AC=FALSE,silent=T)

rho
ac.fit.st$rho
smax
ac.fit.st$Smax
log.a
ac.fit.st$logalpha

static_sr_plot(df=df.ac,mod=ac.fit.st,plot.params=TRUE,resids=TRUE) 
```

What differences do you find in the Ricker parameter estimates and residual plots for when you account for (or not) autocorrelation in the model?


Will it detect any autocorrelation in the entirely stable dataset?

```{r, ac estimates 2}
st.fit.ac=ricker_TMB(data=df.st,AC=TRUE,silent=T)

st.fit.ac$rho
```

There are a few ways to gauge whether autocorrelation in recruitment may exist, in part you can (after some practice) visualize it in the residuals, you can test the parameter with the two model forms as well. One way we could potentially discriminate between the two model forms is using model selection criteria, the *samEst* *TMB* model functions provide estimates of both the $AIC_c$ and $BIC$, which are estimated as:

$AIC_c = -2log(L) + 2k(k+1)/(n-k-1)$
$BIC = klog(n) - 2log(L)$

where $L$ is the model likelihood (estimated from the normal probability density function in our case), $k$ is the number of parameters (so in our comparison the autocorrelation model has +1 parameters), and $n$ is the number of observations. The lower $AIC$ or $BIC$ value, the more support there is for that model.

We can further transform these estimates from each model into model 'weights', which give an estimate of the relative difference in likelihood support among models $I$ as:

$w_i = e^{-AIC_i/2}/sum(e^{-AIC_i:I/2})|$

We have a *samEst* function, $model_weights$ that will perform this calculation.

```{r, ac model selection}
ac.fit.ac$AICc
ac.fit.st$AICc

ac.fit.ac$BIC
ac.fit.st$BIC

model_weights(c(ac.fit.ac$AICc,ac.fit.st$AICc),form='TMB')
model_weights(c(ac.fit.ac$BIC,ac.fit.st$BIC),form='TMB')

```

What can you conclude from this?
 
What about for the stable system?

```{r, st model selection}
st.fit.ac$AICc
tmb.fit1$AICc

st.fit.ac$BIC
tmb.fit1$BIC

model_weights(c(st.fit.ac$AICc,tmb.fit1$AICc),form='TMB')
model_weights(c(st.fit.ac$BIC,tmb.fit1$BIC),form='TMB')

```
## Non-stationary dynamics

The key Ricker model parameters that dictate population dynamics emerge as the integration of several demographic processes - namely survival (at all life stages) and reproductive output. The intrinsic productivity parameter, $log(\alpha)$ represents the density-independent portion, while the capacity parameter $S_{max}$ represents the density-dependent portion. In nature, both of these processes may change through time in tandem with ecosystem conditions - e.g. abiotic environment, predator/prey/competitor abundances, habitat availability, etc. When these parameters shift through time, this results in 'nonstationary' population dynamics.

One way to model nonstationary dynamics is by letting the parameters themselves evolve through time - this is often termed a 'state-space' process. For example, if we let intrinsic productivity vary through time ($log(\alpha)_t$) the revised nonstationary Ricker model would look like this:

$log(R_t/S_t) = log(\alpha)_t - S_t/S_{max} + \epsilon_t$

$log(\alpha)_t = log(\alpha)_{t-1} + \omega_{t}$

$\omega_{t} \sim N(0, \sigma_{\omega})$

$\epsilon_t \sim N(0, \sigma)$

In this formulation, nonstationary productivity changes for each brood cohort $t$ based on the last years estimate ($t-1$) adjusted with some process noise ($\omega_{t}$) that is drawn from a normal distribution with a standard deviation of (\sigma_{\omega}; we can call this process deviance or variance). This portion of the model is equivalent to a 'random walk' or Brownian motion model, that is widely used across fields. Its application to spawner-recruit dynamics was pioneered by Dr. Randall Peterman in a series of papers - so this particular formulation has now been dubbed the 'Peterman's productivity method'.


An alternative form of this would allow the capacity parameter ($S_{max}$) to instead vary through time:

$log(R_t/S_t) = log(\alpha) - S_t/S_{max}_t + \epsilon_t$

The key challenge in these models is that there are now two sources of variance in year-to-year $log(R_t/S_t)$ that arise from both 'low frequency' (ie. it changes gradually through time) process error ($\sigma_{\omega}$) and 'high frequency' (ie. it changes rapidly through time - as 'white noise') annual error ($\sigma_{\omega}$) - the latter of which emerges from both sampling effects (ie. measurement errors in recruits and spawners) as well as true variances in demographic processes among brood cohorts.

This nonstationary models can be in *samEst* using the *ricker_rw_TMB* (or *ricker_rw_stan*) functions. To choose between productivity or capacity changes, one must specify the time-varying parameter(*tv.par* as *a* or *b*, or *both* - but more on 'both' later).

We will test how well these models can actually capture trend trends in these Ricker parameters using another simulation function made for this workshop - here we can change either intrinsic productivity or capacity to time-varying by specifying *par = a* or *par = b* in this function.

In this first simulation, we will develop spawner-recruit dynamics under linear changes. Here in productivity:

```{r, tv sim - linear prod}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.lin.prod=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,par='a',form='linear')
```

Let's fit the non-stationary version of the Ricker model to determine whether it was able to capture the parameter changes in the intrinsic productivity parameter:

```{r, tv est - linear prod}
ns.prod.fit1=ricker_rw_TMB(data=df.lin.prod,tv.par='a',priors=0,silent=T)

plot(df.lin.prod$loga.t,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year')
lines(ns.prod.fit1$logalpha,lwd=2,col='darkred')

```

How well does the estimate approximate the true parameter change? 

Note - under certain conditions it may fail to fit, either you can try the stan version (which tends to be more flexible to imperfect data), flagging priors on (or off), or failing all that re-run the simulated dataset.

Next we can try capacity change:

```{r, tv sim - linear smax}
#Ricker parameters
log.a0=1.5 #static productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.lin.smax=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,par='b',form='linear')
```

```{r, tv est - linear smax}
ns.smax.fit1=ricker_rw_TMB(data=df.lin.smax,tv.par='b',priors=0,silent=T)

plot(df.lin.smax$smax.t,type='l',lwd=2,ylab='Smax parameter',xlab='simulation year')
lines(ns.smax.fit1$Smax,lwd=2,col='darkred')

```

Does this track better or worse than the productivity change estimate?

The previous examples are illustrative of a very basic hypothesis for system changes (ie. linear directional change), in reality the processes driving nonstationary dynamics are likely to be much more temporally complex - we can try out some more realistic scenarios by generating the same datasets with a random walk in the nonstationary parameter, which matches the model estimation form directly. Each iteration should be quite different so keep re-running and estimating to see the diversity of trajectories you can generate.

```{r, tv sim - random walk prod}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.rw.prod=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,par='a',form='rw')

ns.prod.fit3=ricker_rw_TMB(data=df.rw.prod,tv.par='a',priors=0,silent=T)

plot(df.rw.prod$loga.t,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year')
lines(ns.prod.fit3$logalpha,lwd=2,col='darkred')
```


```{r, tv sim - random walk smax}
#Ricker parameters
log.a0=1.5 #initial productivity
p.change=-0.75 #proprtional change in time-varying parameter, -0.75 = -75% (on the log-scale), 0.5 = +50%
smax0=5000 #initial smax
sigma=0.6 #most stocks range from ~0.3 to 1.5
N=50

df.rw.smax=salmon_sim.tv(log.a0=log.a0,p.change=p.change,smax0=smax0,sigma=sigma,N=N,par='b',form='rw')

ns.smax.fit3=ricker_rw_TMB(data=df.rw.smax,tv.par='b',priors=0,silent=T)

plot(df.rw.smax$smax.t,type='l',lwd=2,ylab='Smax parameter',xlab='simulation year')
lines(ns.smax.fit3$Smax,lwd=2,col='darkred')

```

In real time-series of salmon spawner-recruit dynamics, we won't know what parameter is actually nonstationary (if any). Let's apply our estimates to the alternate generating simulation to see what it estimates (note - the simulation datasets are switched to be mismatched):

```{r, tv est - linear crossed,fig.width=6,fig.height=8}
ns.prod.fit2=ricker_rw_TMB(data=df.lin.smax,tv.par='a',priors=0,silent=T)

ns.smax.fit2=ricker_rw_TMB(data=df.lin.prod,tv.par='b',priors=0,silent=T)

par(mfrow=c(2,1))
plot(ns.prod.fit2$logalpha,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year',col='darkred')
lines(df.lin.smax$loga.t,lwd=2) #true prod change
plot(ns.smax.fit2$Smax,type='l',lwd=2,ylab='productivity parameter',xlab='simulation year',col='darkred')
lines(df.lin.prod$smax.t,lwd=2) #true prod change

```

You will notice that estimates of nonstationary productivity and capacity tend to follow the same statistical signal in the time-series, a change in productivity can look like a change in capacity and vice-versa - even though the implied system dynamics are quite different.

Similar to our example comparing autocorrelation and stable dynamics, perhaps we can use model selection to detect the true underlying parameter?

productivity scenario:

```{r, tv est - linear crossed mod sel - prod scenario}
ns.prod.fit1$AICc #prod est matched to prod data
ns.smax.fit2$AICc #smax est matched to prod data

#identifying prod vs capacity change in true productivity change
model_weights(c(ns.prod.fit1$AICc,ns.smax.fit2$AICc),form='TMB')
```

capacity scenario:

```{r, tv est - linear crossed mod sel - smax scenario}
ns.prod.fit2$AICc #prod est matched to prod data
ns.smax.fit1$AICc #smax est matched to prod data

#identifying prod vs capacity change in true productivity change
model_weights(c(ns.prod.fit2$AICc,ns.smax.fit1$AICc),form='TMB')
```

Were you able to correctly identify the true parameter changes based on the model likelihood and selection criteria?
